/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../src/assets/js/modules/HorizontalMenu.js":
/*!**************************************************!*\
  !*** ../src/assets/js/modules/HorizontalMenu.js ***!
  \**************************************************/
/***/ (() => {

eval("class HorizontalMenu {\r\n  /*\r\n          const param = {\r\n              containersMenu: ['.cont-horizont-menu', '.wrap-drop-menu', '#my-menu'], // селекторы контейнеров меню которые будут обрабатываться\r\n              modifiers = {      // объект, модификаторы классов для различия разных типов меню\r\n                      drop:'drop',\r\n                      overflow:'overflow',\r\n                      burger:'burger',\r\n              }\r\n              visibleClass: 'rmbt-visible', // классы для показа элементов\r\n              hiddenClass: 'rmbt-hidden', // классы для скрытия элементов\r\n              iconDropClass: '.icon-drop', // определяет внешний вид иконки когда subMenu закрыто \r\n              iconDropClassOpen: '.icon-drop_open', // Класс который определяет внешний вид иконки когда subMenu открыто. iconDropClass НЕбудет удалён\r\n              iconOverflow: '.icon-overflow', // определяет внешний вид иконки overflow menu\r\n              iconOverflowOpen: '.icon-overflow_open', // определяет внешний вид иконки overflow menu когда overflow menu открыто\r\n              \r\n              iconBurger: 'icon-drop', // определяет внешний вид иконки Burgerr menu\r\n              iconBurgerOpen: 'icon-drop_open', // определяет внешний вид иконки Burgerr menu когда Burgerr menu открыто  iconBurger НЕбудет удалён\r\n              breakPointBurger: 768,      // размер окна при котором происходит перестроения в burger меню из overflow меню\r\n              \r\n              // single: 'false', // допускает одновременное открытие нескольких меню т.е. открытие следующего меню не закрывает предидущее\r\n\r\n              contAdditionalClasses: { // пользаватеьские классы определяющие внешний вид открытых пунтков меню или контейнеров\r\n                  drop: [],\r\n                  overflow: [],\r\n                  burger: [],\r\n              }, \r\n              animation = {     // для каждого вида меню ожидается объект содержащий все свойства/значения, которые вы хотите анимировать для открытия и закрытия отдельно!\r\n                              // соответствующий объект будет использован в методе gsap.to(). \r\n                 drop:{\r\n                     open{},\r\n                     close{}\r\n                 },\r\n                  overflow:{\r\n                      open{},\r\n                      close{}\r\n                  },\r\n                  burger:{\r\n                      open{},\r\n                      close{}\r\n                  },\r\n              } \r\n\r\n          };\r\n\r\n      */\r\n\r\n  // классы скрытых пунтков меню или контейнеров\r\n  hiddenMenuCont = {\r\n    overflow: 'overflow-cont',\r\n    drop: 'drop-cont',\r\n    burger: 'burger-cont',\r\n  };\r\n\r\n  // объект, модификаторы классов для того что бы каждый вид меню мог открываться - закрываться посвоему\r\n  modifiers = {\r\n    drop: 'drop',\r\n    overflow: 'overflow',\r\n    burger: 'burger',\r\n  };\r\n\r\n  // пользаватеьские классы определяющие внешний вид открытых пунтков меню или контейнеров\r\n  contAdditionalClasses = {\r\n    drop: [],\r\n    overflow: [],\r\n    burger: [],\r\n  };\r\n\r\n  animation = {\r\n    drop: {\r\n      open: {\r\n        duration: 0.7,\r\n        ease: 'power4.inOut',\r\n        height: 'auto',\r\n        overflow: 'visible',\r\n        pointerEvents: 'auto',\r\n        opacity: 1,\r\n        // width: 'auto',\r\n      },\r\n      close: {\r\n        duration: 0.7,\r\n        ease: 'power4.inOut',\r\n        height: 0,\r\n        overflow: 'hidden',\r\n        pointerEvents: 'none',\r\n        opacity: 0,\r\n        // width: 0,\r\n      },\r\n    },\r\n    overflow: {\r\n      open: {\r\n        duration: 0.7,\r\n        ease: 'power4.inOut',\r\n        height: 'auto',\r\n        overflow: 'visible',\r\n        pointerEvents: 'auto',\r\n        opacity: 1,\r\n        width: 'auto',\r\n      },\r\n      close: {\r\n        duration: 0.7,\r\n        ease: 'power4.inOut',\r\n        height: 0,\r\n        overflow: 'hidden',\r\n        pointerEvents: 'none',\r\n        opacity: 0,\r\n        width: 0,\r\n      },\r\n    },\r\n    burger: {\r\n      open: {\r\n        duration: 0.7,\r\n        ease: 'power4.inOut',\r\n        overflow: 'visible',\r\n        pointerEvents: 'auto',\r\n        opacity: 1,\r\n        width: 'auto',\r\n      },\r\n      close: {\r\n        duration: 0.7,\r\n        ease: 'power4.inOut',\r\n        overflow: 'hidden',\r\n        pointerEvents: 'none',\r\n        opacity: 0,\r\n        width: 0,\r\n      },\r\n    },\r\n  };\r\n\r\n  constructor(param) {\r\n    this.containersMenu = param.containersMenu || '.cont-horizont-menu';\r\n    this.nl_containersMenu = this._getArrNodeLists(this.containersMenu);\r\n    if (this.nl_containersMenu.length == 0) {\r\n      // throw new Error('Menus with given selectors  are absent on this page');\r\n      return;\r\n    }\r\n    this.contAdditionalClasses = param.contAdditionalClasses;\r\n    this.iconOverflow = this._clearClassName(param.iconOverflow || 'icon-overflow');\r\n    this.iconBurger = this._clearClassName(param.iconBurger || 'icon-burger');\r\n    this.iconBurgerOpen = this._clearClassName(\r\n      param.iconBurgerOpen || 'icon-burger_open'\r\n    );\r\n    this.iconDropClass = this._clearClassName(param.iconDropClass || 'icon-drop');\r\n    this.iconDropClassOpen = this._clearClassName(\r\n      param.iconDropdownmodifiereOpen || 'icon-drop_open'\r\n    );\r\n    this.breakPointBurger = param.breakPointBurger || 769;\r\n\r\n    this.visibleClass = this._clearClassName(param.visibleClass || 'rmbt-visible');\r\n    this.hiddenClass = this._clearClassName(param.hiddenClass || 'rmbt-hidden');\r\n    this.single = param.single || 'true';\r\n\r\n    this.lastWidthWindow = window.innerWidth;\r\n\r\n    this.forEachMenu();\r\n    this.listenClick();\r\n    this.listenKeydown();\r\n  }\r\n\r\n  forEachMenu() {\r\n    for (let index = 0; index < this.nl_containersMenu.length; index++) {\r\n      const arrNodeList = this.nl_containersMenu[index];\r\n\r\n      for (let i = 0; i <= arrNodeList.length - 1; i++) {\r\n        let contCurrentMenu = arrNodeList[i];\r\n        if (!contCurrentMenu.querySelector('nav')) continue;\r\n        this.monitoringResize(contCurrentMenu);\r\n        this.menuContainerDrop(contCurrentMenu);\r\n        this.setSubMenuIcon(contCurrentMenu);\r\n        this.setBurgerIcon(contCurrentMenu);\r\n      }\r\n    }\r\n  }\r\n\r\n  clearNav(contCurrentMenu) {\r\n    if (\r\n      contCurrentMenu.querySelector('nav').classList.contains(this.hiddenClass) ||\r\n      contCurrentMenu\r\n        .querySelector('nav')\r\n        .classList.contains(`${this.visibleClass}_${this.modifiers.burger}`)\r\n    ) {\r\n      contCurrentMenu.querySelector('nav').className = '';\r\n      if (typeof gsap !== 'undefined') {\r\n        Object.keys(this.animation.burger.close).forEach(prop => {\r\n          prop = prop.replace(/[A-Z]/g, match => `-${match.toLowerCase()}`);\r\n          contCurrentMenu.querySelector('nav').style.setProperty(prop, '');\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  menuContainerOverflow(contCurrentMenu) {\r\n    let overflowCont = contCurrentMenu.querySelector(`.${this.hiddenMenuCont.overflow}`);\r\n    let ul = contCurrentMenu.querySelector('ul');\r\n    let createdOverflowCont = false;\r\n\r\n    if (overflowCont) {\r\n      if (overflowCont.childElementCount > 0) return overflowCont;\r\n    } else {\r\n      overflowCont = document.createElement('ul');\r\n      overflowCont.classList.add(this.hiddenMenuCont.overflow, this.hiddenClass);\r\n      createdOverflowCont = true;\r\n    }\r\n\r\n    this.clearNav(contCurrentMenu);\r\n\r\n    contCurrentMenu.querySelectorAll('nav>ul>li').forEach(elMenu => {\r\n      if (elMenu.getBoundingClientRect().right - ul.getBoundingClientRect().right > 1) {\r\n        overflowCont.append(elMenu);\r\n      }\r\n    });\r\n\r\n    if (overflowCont.childElementCount > 0) {\r\n      if (createdOverflowCont) {\r\n        contCurrentMenu.querySelector('nav').append(overflowCont);\r\n        this.setAdditionalClassesToCont(overflowCont, 'overflow');\r\n        contCurrentMenu.style.visibility = 'visible'; // показываю меню после окончательного формирования\r\n      }\r\n      if (!contCurrentMenu.querySelector(this.iconOverflow))\r\n        this.setOverflowIcon(contCurrentMenu);\r\n      return overflowCont;\r\n    }\r\n\r\n    contCurrentMenu.style.visibility = 'visible'; // показываю меню после окончательного формирования\r\n    return null;\r\n  }\r\n\r\n  monitoringResize(contCurrentMenu) {\r\n    const currentMenu = contCurrentMenu.querySelector('nav>ul:first-child');\r\n    const paddingRightCurrentMenu = +window\r\n      .getComputedStyle(contCurrentMenu.querySelector('nav'))\r\n      .paddingRight.replace(/px/g, '');\r\n    const paddingRightcontCurrentMenu = +window\r\n      .getComputedStyle(contCurrentMenu)\r\n      .paddingRight.replace(/px/g, '');\r\n    let prevRightCont = contCurrentMenu.getBoundingClientRect().right;\r\n\r\n    const observer = new ResizeObserver(entries => {\r\n      if (window.innerWidth <= this.breakPointBurger) {\r\n        contCurrentMenu.style.visibility = 'visible';\r\n        return;\r\n      }\r\n\r\n      if (\r\n        contCurrentMenu\r\n          .querySelector(`.${this.iconBurger}`)\r\n          .classList.contains(this.iconBurgerOpen)\r\n      ) {\r\n        this.changeStateIconMenu(\r\n          contCurrentMenu.querySelector('nav'),\r\n          this.modifiers.burger,\r\n          'close'\r\n        );\r\n      }\r\n\r\n      this.clearNav(contCurrentMenu);\r\n\r\n      let overflowCont = this.menuContainerOverflow(contCurrentMenu);\r\n      if (overflowCont === null) return;\r\n      let widthPrevFirstOverflowLi = 0;\r\n      let prevFirstOverflowLi = overflowCont.querySelector('li:first-child');\r\n      if (prevFirstOverflowLi)\r\n        widthPrevFirstOverflowLi = prevFirstOverflowLi.getBoundingClientRect().width;\r\n\r\n      const mainUl = contCurrentMenu.querySelector('nav ul');\r\n      const currentRightMainUl = mainUl.getBoundingClientRect().right;\r\n      const currentRightCont = contCurrentMenu.getBoundingClientRect().right;\r\n\r\n      let prevlastLi, prevRightlastLi;\r\n      if (contCurrentMenu.querySelector('nav>ul:first-child>li:last-child')) {\r\n        prevlastLi = contCurrentMenu.querySelector('nav>ul:first-child>li:last-child');\r\n        prevRightlastLi = prevlastLi.getBoundingClientRect().right;\r\n      }\r\n\r\n      const sumDistanceBetweenLi = [\r\n        ...contCurrentMenu.querySelectorAll('nav>ul:first-child>li'),\r\n      ].reduce((accum, li, i, arr) => {\r\n        if (arr[i + 1])\r\n          accum +=\r\n            arr[i + 1].getBoundingClientRect().left - li.getBoundingClientRect().right;\r\n        return accum;\r\n      }, 0);\r\n\r\n      if (currentRightCont - prevRightCont < 0) {\r\n        // окно уменьшается\r\n        if (prevRightlastLi > currentRightMainUl) overflowCont.prepend(prevlastLi);\r\n      } else {\r\n        // окно увеличивается\r\n        if (\r\n          sumDistanceBetweenLi - widthPrevFirstOverflowLi >\r\n          (paddingRightCurrentMenu + paddingRightcontCurrentMenu) * 2\r\n        ) {\r\n          if (prevFirstOverflowLi) currentMenu.append(prevFirstOverflowLi);\r\n          if (\r\n            contCurrentMenu.querySelectorAll(`.${this.hiddenMenuCont.overflow}>li`)\r\n              .length == 0\r\n          ) {\r\n            if (contCurrentMenu.querySelector('.icon-overflow'))\r\n              contCurrentMenu.querySelector('.icon-overflow').remove();\r\n          }\r\n        }\r\n      }\r\n      prevRightCont = currentRightCont;\r\n    });\r\n    observer.observe(contCurrentMenu);\r\n  }\r\n\r\n  menuContainerDrop(contCurrentMenu) {\r\n    let subMenus = contCurrentMenu.querySelectorAll('nav>ul ul');\r\n    if (subMenus.length > 0) {\r\n      subMenus.forEach(subMenu => {\r\n        subMenu.classList.add(this.hiddenMenuCont.drop, this.hiddenClass);\r\n        this.setAdditionalClassesToCont(subMenu, 'drop');\r\n      });\r\n    }\r\n  }\r\n\r\n  setAdditionalClassesToCont(currentMenu, typeMenu) {\r\n    if (typeMenu === 'overflow') {\r\n      classesIteration(this.contAdditionalClasses.overflow);\r\n    } else if (typeMenu === 'drop') {\r\n      classesIteration(this.contAdditionalClasses.drop);\r\n    } else if (typeMenu === 'burger') {\r\n      classesIteration(this.contAdditionalClasses.burger);\r\n    }\r\n\r\n    function classesIteration(arrClassies) {\r\n      arrClassies.forEach(_class => currentMenu.classList.add(_class));\r\n    }\r\n  }\r\n\r\n  /* \r\n          search sub menu and set sub menu icon if finde\r\n      */\r\n  setSubMenuIcon(contCurrentMenu) {\r\n    const itemsMenu = contCurrentMenu.querySelectorAll(`nav li`);\r\n    for (let i = 0; i <= itemsMenu.length - 1; i++) {\r\n      if (itemsMenu[i].querySelectorAll('ul').length === 0) continue; // Пропустить элементы без sub menu\r\n      let iconDropdown = document.createElement('div');\r\n      if (!itemsMenu[i].querySelector(`.${this.iconDropClass}`)) {\r\n        iconDropdown.classList.add(this.iconDropClass);\r\n      }\r\n      itemsMenu[i].append(iconDropdown);\r\n    }\r\n  }\r\n\r\n  setOverflowIcon(contCurrentMenu) {\r\n    let iconOverflow = document.createElement('div');\r\n    let span = document.createElement('span');\r\n    iconOverflow.append(span);\r\n    iconOverflow.classList.add(this.iconOverflow);\r\n    contCurrentMenu.querySelector('nav').append(iconOverflow);\r\n  }\r\n\r\n  setBurgerIcon(contCurrentMenu) {\r\n    let iconBurger = document.createElement('div');\r\n    let iconBurgerSpan = document.createElement('span');\r\n    iconBurger.classList.add(this.iconBurger);\r\n    iconBurger.append(iconBurgerSpan);\r\n    contCurrentMenu.prepend(iconBurger);\r\n  }\r\n\r\n  changeStateIconMenu(currentMenu, modifier, state) {\r\n    switch (modifier) {\r\n      case this.modifiers.drop:\r\n        let parentLi = currentMenu.closest('li');\r\n        if (parentLi === null) {\r\n          return;\r\n        }\r\n        parentLi.childNodes.forEach(node => {\r\n          try {\r\n            if (node.classList.contains(this.iconDropClass)) {\r\n              if (state == 'open') {\r\n                node.classList.add(this.iconDropClassOpen);\r\n                exit = true;\r\n                return;\r\n              } else if (state == 'close') {\r\n                node.classList.remove(this.iconDropClassOpen);\r\n                exit = true;\r\n                return;\r\n              }\r\n            }\r\n          } catch {}\r\n        });\r\n        break;\r\n\r\n      case this.modifiers.burger:\r\n        this.containersMenu.forEach(menuSel => {\r\n          let parrentMenu = currentMenu.closest(menuSel);\r\n\r\n          if (parrentMenu) {\r\n            let iconBurger = parrentMenu.querySelector(`.${this.iconBurger}`);\r\n\r\n            if (state == 'open') {\r\n              iconBurger.classList.add(this.iconBurgerOpen);\r\n              currentMenu.prepend(iconBurger);\r\n            } else if (state == 'close') {\r\n              iconBurger.classList.remove(this.iconBurgerOpen);\r\n              parrentMenu.append(iconBurger);\r\n            }\r\n          }\r\n        });\r\n\r\n        break;\r\n\r\n      case this.modifiers.overflow:\r\n        /*something*/\r\n        break;\r\n    }\r\n  }\r\n\r\n  closeMenu(currentMenu) {\r\n    let modifier;\r\n    if (currentMenu.classList.contains(this.visibleClass + '_' + this.modifiers.drop)) {\r\n      modifier = this.modifiers.drop;\r\n    } else if (\r\n      currentMenu.classList.contains(this.visibleClass + '_' + this.modifiers.burger)\r\n    ) {\r\n      modifier = this.modifiers.burger;\r\n    } else if (\r\n      currentMenu.classList.contains(this.visibleClass + '_' + this.modifiers.overflow)\r\n    ) {\r\n      modifier = this.modifiers.overflow;\r\n    }\r\n\r\n    if (typeof gsap !== 'undefined') {\r\n      if (modifier === this.modifiers.drop) {\r\n        gsap.to(currentMenu, this.animation.drop.close).play();\r\n      } else if (modifier === this.modifiers.overflow) {\r\n        gsap.to(currentMenu, this.animation.overflow.close).play();\r\n      } else if (modifier === this.modifiers.burger) {\r\n        gsap.to(currentMenu, this.animation.burger.close).play();\r\n      }\r\n    }\r\n\r\n    currentMenu.classList.remove(this.visibleClass + '_' + modifier);\r\n    currentMenu.classList.add(this.hiddenClass);\r\n\r\n    if (modifier === this.modifiers.burger) {\r\n      document.querySelector('html').classList.remove('rmbt-lock');\r\n    }\r\n    this.changeStateIconMenu(currentMenu, modifier, 'close');\r\n  }\r\n\r\n  OpenMenu(currentMenu, modifier) {\r\n    this.checSingle(currentMenu);\r\n\r\n    if (typeof gsap !== 'undefined') {\r\n      if (modifier === this.modifiers.drop) {\r\n        gsap.to(currentMenu, this.animation.drop.open).play();\r\n      } else if (modifier === this.modifiers.overflow) {\r\n        gsap.to(currentMenu, this.animation.overflow.open).play();\r\n      } else if (modifier === this.modifiers.burger) {\r\n        gsap.to(currentMenu, this.animation.burger.open).play();\r\n      }\r\n    } else {\r\n      currentMenu.classList.remove(this.hiddenClass);\r\n    }\r\n\r\n    if (modifier === this.modifiers.burger) {\r\n      document.querySelector('html').classList.add('rmbt-lock');\r\n      let overflowCont = currentMenu.querySelector(`.${this.hiddenMenuCont.overflow}`);\r\n      if (overflowCont) {\r\n        if (\r\n          currentMenu.querySelectorAll(`.${this.hiddenMenuCont.overflow}>li`).length > 0\r\n        ) {\r\n          currentMenu\r\n            .querySelectorAll(`.${this.hiddenMenuCont.overflow}>li`)\r\n            .forEach(li => {\r\n              currentMenu.querySelector('nav>ul:first-child').append(li);\r\n            });\r\n        }\r\n      }\r\n    }\r\n\r\n    currentMenu.classList.add(this.visibleClass + '_' + modifier);\r\n    this.changeStateIconMenu(currentMenu, modifier, 'open');\r\n  }\r\n\r\n  checSingle(currentMenu) {\r\n    if (this.single !== 'true') {\r\n      return null;\r\n    }\r\n\r\n    let flaf = 0;\r\n    let arr_values = Object.values(this.modifiers);\r\n\r\n    for (var i = arr_values.length - 1; i >= 0; i--) {\r\n      if (currentMenu.closest(`.${this.visibleClass}_${arr_values[i]}`)) {\r\n        flaf = 1;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (flaf == 0) {\r\n      let openedMenu = this._getAllOpenMenus();\r\n      if (openedMenu.length > 0) {\r\n        openedMenu.forEach(openedMenu => {\r\n          this.closeMenu(openedMenu); ///!!!!  проблема в том что this.animation.tween затирается следующим открытым меню\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  listenClick() {\r\n    document.addEventListener('click', e => {\r\n      let target = e.target;\r\n\r\n      if (target.classList.contains(this.iconDropClassOpen)) {\r\n        let parentMenu = target.closest('li');\r\n        let currentMenu = parentMenu.querySelector(`.${this.hiddenMenuCont.drop}`);\r\n        this.closeMenu(currentMenu);\r\n      } else if (target.classList.contains(this.iconBurgerOpen)) {\r\n        let currentMenu = target.closest(\r\n          `.${this.visibleClass}_${this.modifiers.burger}`\r\n        );\r\n        this.closeMenu(currentMenu);\r\n      } else if (target.classList.contains(this.iconDropClass)) {\r\n        let currentMenu = target\r\n          .closest('li')\r\n          .querySelector(`.${this.hiddenMenuCont.drop}`);\r\n        this.OpenMenu(currentMenu, this.modifiers.drop);\r\n      } else if (\r\n        target.classList.contains(this.iconOverflow) ||\r\n        target.closest(`.${this.iconOverflow}`)\r\n      ) {\r\n        let currentMenu = target\r\n          .closest('nav')\r\n          .querySelector(`.${this.hiddenMenuCont.overflow}`);\r\n        this.OpenMenu(currentMenu, this.modifiers.overflow);\r\n      } else if (target.classList.contains(this.iconBurger)) {\r\n        this.containersMenu.forEach(menuSel => {\r\n          if (target.closest(menuSel)) {\r\n            let currentMenu = target.closest(menuSel).querySelector(`nav`);\r\n            this.OpenMenu(currentMenu, this.modifiers.burger);\r\n          }\r\n        });\r\n      } else {\r\n        this.clickOut();\r\n      }\r\n    });\r\n  }\r\n\r\n  clickOut() {\r\n    let nl_menus = this._getAllOpenMenus();\r\n\r\n    if (nl_menus.length > 0)\r\n      nl_menus.forEach(menu => {\r\n        this.closeMenu(menu);\r\n      });\r\n  }\r\n\r\n  listenKeydown() {\r\n    document.addEventListener('keydown', e => {\r\n      if (e.key === 27 || e.keyCode === 27) {\r\n        let nl_menus = this._getAllOpenMenus();\r\n        if (nl_menus.length > 0)\r\n          nl_menus.forEach(menu => {\r\n            this.closeMenu(menu, 'drop');\r\n          });\r\n      }\r\n    });\r\n  }\r\n\r\n  //========= helpers ============\r\n\r\n  /*\r\n          удаляет повторяющиеся значения\r\n      */\r\n  _uniqueArr(arr) {\r\n    return [\r\n      ...new Set(\r\n        arr\r\n          .map(el => {\r\n            if (typeof str === 'string') this._clearClassName(el);\r\n          })\r\n          .filter(item => item !== undefined)\r\n      ),\r\n    ];\r\n  }\r\n\r\n  /*\r\n            очистка имён классов\r\n        */\r\n\r\n  _clearClassName(str) {\r\n    if (typeof str !== 'string') {\r\n      return '';\r\n    }\r\n    const patternDot = /^\\./;\r\n    return str.replace(patternDot, '');\r\n  }\r\n\r\n  /*\r\n            возвращает массив nodeList элементов по их селекторам\r\n        */\r\n  _getArrNodeLists(date) {\r\n    if (Array.isArray(date)) {\r\n      let nl_menus = date\r\n        .map(el => document.querySelectorAll(el))\r\n        .filter((menu, index, nodeList) => {\r\n          if (menu.length > 0) {\r\n            return menu;\r\n          }\r\n        });\r\n\r\n      return nl_menus;\r\n    }\r\n  }\r\n\r\n  /*\r\n          преобразует одномерный массив из n-мерного массива\r\n      */\r\n  _flattenArray(arr) {\r\n    let flatArray = [];\r\n    arr.forEach(element => {\r\n      if (Array.isArray(element)) {\r\n        flatArray.push(...this._flattenArray(element));\r\n      } else {\r\n        flatArray.push(element);\r\n      }\r\n    });\r\n\r\n    return this._uniqueArr(flatArray);\r\n  }\r\n\r\n  _getAllOpenMenus() {\r\n    let entries = Object.entries(this.modifiers);\r\n    let arr_menu = entries.map(([key, mod]) => [\r\n      ...document.querySelectorAll(`.${this.visibleClass}_${mod}`),\r\n    ]);\r\n    arr_menu = arr_menu.flat();\r\n\r\n    return arr_menu;\r\n  }\r\n}\r\n\r\nconst param = {\r\n  containersMenu: ['.cont-horizont-menu'],\r\n  contAdditionalClasses: {\r\n    drop: [],\r\n    overflow: [],\r\n    burger: [],\r\n  },\r\n  // animation: {\r\n  //     drop: {},\r\n  //     overflow: {},\r\n  //     burger: {},\r\n  // }\r\n};\r\n\r\nconst menu = new HorizontalMenu(param);\r\n\n\n//# sourceURL=webpack://gulp-assembly/../src/assets/js/modules/HorizontalMenu.js?");

/***/ }),

/***/ "../src/assets/js/modules/arrowsInputNumberStyle.js":
/*!**********************************************************!*\
  !*** ../src/assets/js/modules/arrowsInputNumberStyle.js ***!
  \**********************************************************/
/***/ (() => {

eval("/**\r\n *\r\n * must be this html, look in the snippets:\r\n *\r\n * <div class=\"quantity-block\">\r\n *    <button class=\"quantity-arrow-minus\" type=\"button\"> - </button>\r\n *    <input class=\"quantity-num\" type=\"number\" value=\"1\" />\r\n *    <button class=\"quantity-arrow-plus\" type=\"button\"> + </button>\r\n * </div>\r\n *\r\n *\r\n */\r\n\r\nfunction quantityProducts() {\r\n  const QuantityBlocks = document.querySelectorAll(`.quantity`); // class of blocks quantity\r\n  const changeEvent = new Event('change', { bubbles: true });\r\n\r\n  QuantityBlocks.forEach(element => {\r\n    const quantityArrowMinus = element.querySelector('.quantity-arrow-minus');\r\n    const quantityArrowPlus = element.querySelector('.quantity-arrow-plus');\r\n\r\n    if (!quantityArrowMinus || !quantityArrowPlus) {\r\n      return;\r\n    }\r\n\r\n    const input = element.querySelector(`input`);\r\n\r\n    quantityArrowMinus.addEventListener('click', quantityMinus);\r\n    quantityArrowPlus.addEventListener('click', quantityPlus);\r\n\r\n    function quantityMinus(e) {\r\n      input.dispatchEvent(changeEvent);\r\n      if (input.value > 1) input.value = +input.value - 1;\r\n    }\r\n\r\n    function quantityPlus(e) {\r\n      input.dispatchEvent(changeEvent);\r\n      input.value = +input.value + 1;\r\n    }\r\n  });\r\n}\r\n\r\nquantityProducts();\r\n\r\ntry {\r\n  jQuery(document).ajaxComplete(function () {\r\n    // as  after ajax loading form it elements are changed\r\n    quantityProducts();\r\n  });\r\n} catch (error) {\r\n  // console.error('jQuery is not enabled:', error);\r\n}\r\n\n\n//# sourceURL=webpack://gulp-assembly/../src/assets/js/modules/arrowsInputNumberStyle.js?");

/***/ }),

/***/ "../src/assets/js/modules/dynamic_adapt.js":
/*!*************************************************!*\
  !*** ../src/assets/js/modules/dynamic_adapt.js ***!
  \*************************************************/
/***/ (() => {

"use strict";
eval("// Dynamic Adapt v.1\r\n// HTML data-da=\"where(uniq class name),when(breakpoint),position(ordinal number - digi or first or last)\"\r\n// e.x. data-da=\".item,992,2\"\r\n// Andrikanych Yevhen 2020\r\n// https://www.youtube.com/c/freelancerlifestyle\r\n\r\n\r\nfunction DynamicAdapt(type) {\r\n\tthis.type = type;\r\n}\r\nDynamicAdapt.prototype.init = function () {\r\n\tconst _this = this;\r\n\t// массив объектов\r\n\tthis.оbjects = [];\r\n\tthis.daClassname = \"_dynamic_adapt_\";\r\n\t// массив DOM-элементов\r\n\tthis.nodes = document.querySelectorAll(\"[data-da]\");\r\n\t// наполнение оbjects объктами\r\n\tfor (let i = 0; i < this.nodes.length; i++) {\r\n\t\tconst node = this.nodes[i];\r\n\t\tconst data = node.dataset.da.trim();\r\n\t\tconst dataArray = data.split(\",\");\r\n\t\tconst оbject = {};\r\n\t\tоbject.element = node;\r\n\t\tоbject.parent = node.parentNode;\r\n\t\tоbject.destination = document.querySelector(dataArray[0].trim());\r\n\t\tоbject.breakpoint = dataArray[1] ? dataArray[1].trim() : \"767\";\r\n\t\tоbject.place = dataArray[2] ? dataArray[2].trim() : \"last\";\r\n\t\tоbject.index = this.indexInParent(оbject.parent, оbject.element);\r\n\t\tthis.оbjects.push(оbject);\r\n\t}\r\n\tthis.arraySort(this.оbjects);\r\n\t// массив уникальных медиа-запросов\r\n\tthis.mediaQueries = Array.prototype.map.call(this.оbjects, function (item) {\r\n\t\treturn '(' + this.type + \"-width: \" + item.breakpoint + \"px),\" + item.breakpoint;\r\n\t}, this);\r\n\tthis.mediaQueries = Array.prototype.filter.call(this.mediaQueries, function (item, index, self) {\r\n\t\treturn Array.prototype.indexOf.call(self, item) === index;\r\n\t});\r\n\t// навешивание слушателя на медиа-запрос\r\n\t// и вызов обработчика при первом запуске\r\n\tfor (let i = 0; i < this.mediaQueries.length; i++) {\r\n\t\tconst media = this.mediaQueries[i];\r\n\t\tconst mediaSplit = String.prototype.split.call(media, ',');\r\n\t\tconst matchMedia = window.matchMedia(mediaSplit[0]);\r\n\t\tconst mediaBreakpoint = mediaSplit[1];\r\n\t\t// массив объектов с подходящим брейкпоинтом\r\n\t\tconst оbjectsFilter = Array.prototype.filter.call(this.оbjects, function (item) {\r\n\t\t\treturn item.breakpoint === mediaBreakpoint;\r\n\t\t});\r\n\t\tmatchMedia.addListener(function () {\r\n\t\t\t_this.mediaHandler(matchMedia, оbjectsFilter);\r\n\t\t});\r\n\t\tthis.mediaHandler(matchMedia, оbjectsFilter);\r\n\t}\r\n};\r\nDynamicAdapt.prototype.mediaHandler = function (matchMedia, оbjects) {\r\n\tif (matchMedia.matches) {\r\n\t\tfor (let i = 0; i < оbjects.length; i++) {\r\n\t\t\tconst оbject = оbjects[i];\r\n\t\t\tоbject.index = this.indexInParent(оbject.parent, оbject.element);\r\n\t\t\tthis.moveTo(оbject.place, оbject.element, оbject.destination);\r\n\t\t}\r\n\t} else {\r\n\t\t//for (let i = 0; i < оbjects.length; i++) {\r\n\t\tfor (let i = оbjects.length - 1; i >= 0; i--) {\r\n\t\t\tconst оbject = оbjects[i];\r\n\t\t\tif (оbject.element.classList.contains(this.daClassname)) {\r\n\t\t\t\tthis.moveBack(оbject.parent, оbject.element, оbject.index);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n// Функция перемещения\r\nDynamicAdapt.prototype.moveTo = function (place, element, destination) {\r\n\telement.classList.add(this.daClassname);\r\n\tif (place === 'last' || place >= destination.children.length) {\r\n\t\tdestination.insertAdjacentElement('beforeend', element);\r\n\t\treturn;\r\n\t}\r\n\tif (place === 'first') {\r\n\t\tdestination.insertAdjacentElement('afterbegin', element);\r\n\t\treturn;\r\n\t}\r\n\tdestination.children[place].insertAdjacentElement('beforebegin', element);\r\n}\r\n// Функция возврата\r\nDynamicAdapt.prototype.moveBack = function (parent, element, index) {\r\n\telement.classList.remove(this.daClassname);\r\n\tif (parent.children[index] !== undefined) {\r\n\t\tparent.children[index].insertAdjacentElement('beforebegin', element);\r\n\t} else {\r\n\t\tparent.insertAdjacentElement('beforeend', element);\r\n\t}\r\n}\r\n// Функция получения индекса внутри родителя\r\nDynamicAdapt.prototype.indexInParent = function (parent, element) {\r\n\tconst array = Array.prototype.slice.call(parent.children);\r\n\treturn Array.prototype.indexOf.call(array, element);\r\n};\r\n// Функция сортировки массива по breakpoint и place \r\n// по возрастанию для this.type = min\r\n// по убыванию для this.type = max\r\nDynamicAdapt.prototype.arraySort = function (arr) {\r\n\tif (this.type === \"min\") {\r\n\t\tArray.prototype.sort.call(arr, function (a, b) {\r\n\t\t\tif (a.breakpoint === b.breakpoint) {\r\n\t\t\t\tif (a.place === b.place) {\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (a.place === \"first\" || b.place === \"last\") {\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (a.place === \"last\" || b.place === \"first\") {\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn a.place - b.place;\r\n\t\t\t}\r\n\r\n\t\t\treturn a.breakpoint - b.breakpoint;\r\n\t\t});\r\n\t} else {\r\n\t\tArray.prototype.sort.call(arr, function (a, b) {\r\n\t\t\tif (a.breakpoint === b.breakpoint) {\r\n\t\t\t\tif (a.place === b.place) {\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (a.place === \"first\" || b.place === \"last\") {\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (a.place === \"last\" || b.place === \"first\") {\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn b.place - a.place;\r\n\t\t\t}\r\n\r\n\t\t\treturn b.breakpoint - a.breakpoint;\r\n\t\t});\r\n\t\treturn;\r\n\t}\r\n};\r\nconst da = new DynamicAdapt(\"max\");\r\nda.init();\n\n//# sourceURL=webpack://gulp-assembly/../src/assets/js/modules/dynamic_adapt.js?");

/***/ }),

/***/ "../src/assets/js/modules/functions.js":
/*!*********************************************!*\
  !*** ../src/assets/js/modules/functions.js ***!
  \*********************************************/
/***/ (() => {

eval("/* Проверка мобильного браузера */\r\nisMobile = {\r\n    Android: function() { return navigator.userAgent.match(/Android/i); },\r\n    BlackBerry: function() { return navigator.userAgent.match(/BlackBerry/i); },\r\n    iOS: function() { return navigator.userAgent.match(/iPhone|iPad|iPod/i); },\r\n    Opera: function() { return navigator.userAgent.match(/Opera Mini/i); },\r\n    Windows: function() { return navigator.userAgent.match(/IEMobile/i); },\r\n    any: function() { return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows()); }\r\n};\r\n\r\n/* Добавление класса touch для тега htl если браузер мобильный */\r\nfunction addTouchClass() {\r\n    if (isMobile.any()) document.documentElement.classList.add('touch');\r\n}\r\naddTouchClass();\r\n\r\n/* Проверка поддерживает ли браузер webp */\r\nfunction testWebp(callback) {\r\n    let webP = new Image();\r\n    webP.onload = webP.onerror = function() {\r\n        callback(webP.height == 2);\r\n    };\r\n    webP.src = \"data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA\";\r\n}\r\ntestWebp(function(support) {\r\n    let className = support === true ? 'webp' : 'no-webp';\r\n    document.documentElement.classList.add(className);\r\n});\r\n\r\n/* Smooth scrolling when clicking.\r\n *  scrolling to sections pointed into param data-goto\r\n *  Set element to which  will be scroll. For example a header with position: fixed. \r\n *  Element to which  will be scroll must have attribute data-gotoOffset\r\n */\r\nlet toWhichWillBeScroll = document.querySelector('[data-gotoOffset]');\r\ntoWhichWillBeScroll = toWhichWillBeScroll ? (toWhichWillBeScroll.offsetHeight + toWhichWillBeScroll.offsetTop) : 0;\r\nconst gotoLinks = document.querySelectorAll('[data-goto]');\r\nif (gotoLinks.length > 0) {\r\n    gotoLinks.forEach(gotoLink => {\r\n        gotoLink.addEventListener('click', onGotoLinkCick);\r\n    });\r\n\r\n    function onGotoLinkCick(e) {\r\n        const gotoLink = e.target;\r\n        if (gotoLink.dataset.goto && document.querySelector(gotoLink.dataset.goto)) {\r\n            const gotoBlock = document.querySelector(gotoLink.dataset.goto);\r\n            const gotoBlockValue = gotoBlock.getBoundingClientRect().top + pageYOffset - toWhichWillBeScroll;\r\n\r\n            window.scrollTo({\r\n                top: gotoBlockValue,\r\n                behavior: 'smooth',\r\n            });\r\n\r\n            e.preventDefault();\r\n        }\r\n    }\r\n}\n\n//# sourceURL=webpack://gulp-assembly/../src/assets/js/modules/functions.js?");

/***/ }),

/***/ "../src/assets/js/modules/popup.js":
/*!*****************************************!*\
  !*** ../src/assets/js/modules/popup.js ***!
  \*****************************************/
/***/ (() => {

eval("const mainContainerClass = 'rmbt-page-wrap'; // class your main container\r\nconst timeout = 800; // the quantity  of milliseconds must be equal to the animation time in the 'transition' property in the file popup.js\r\n\r\nconst popupLinks = document.querySelectorAll('.popup-link');\r\nconst body = document.querySelector('body');\r\nconst lockPadding = document.querySelectorAll('.lockPadding');\r\n\r\nlet unLock = true;\r\n\r\nif (popupLinks.length > 0) {\r\n  for (let i = 0; i < popupLinks.length; i++) {\r\n    const popupLink = popupLinks[i];\r\n    popupLink.addEventListener('click', function (e) {\r\n      const popupName = popupLink.getAttribute('href').replace('#', '');\r\n      const currentPopup = document.getElementById(popupName);\r\n      popupOpen(currentPopup);\r\n      e.preventDefault();\r\n    });\r\n  }\r\n}\r\nconst popupCloseIcon = document.querySelectorAll('.popup__close-window');\r\nif (popupCloseIcon.length > 0) {\r\n  for (var i = 0; i < popupCloseIcon.length; i++) {\r\n    const el = popupCloseIcon[i];\r\n    el.addEventListener('click', function (e) {\r\n      e.preventDefault();\r\n      popupClose(el.closest('.popup'));\r\n    });\r\n  }\r\n}\r\n\r\nfunction popupOpen(currentPopup) {\r\n  if (currentPopup && unLock) {\r\n    const popupActive = document.querySelector('.popup.open');\r\n    if (popupActive) {\r\n      popupClose(popupActive, false);\r\n    } else {\r\n      bodyLock();\r\n    }\r\n    currentPopup.classList.add('open');\r\n    currentPopup.addEventListener('click', function (e) {\r\n      if (!e.target.closest('.popup__body')) {\r\n        popupClose(e.target.closest('.popup'));\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction popupClose(popupActive, downLock = true) {\r\n  if (unLock) {\r\n    popupActive.classList.remove('open');\r\n    if (downLock) {\r\n      bodyUnLock();\r\n    }\r\n  }\r\n}\r\n\r\nfunction bodyLock() {\r\n  const lockPaddingValue = window.innerWidth - document.querySelector(`.${mainContainerClass}`).offsetWidth + 'px';\r\n  if (lockPadding.length > 0) {\r\n    for (let i = 0; i < lockPadding.length; i++) {\r\n      const el = lockPadding[i];\r\n      el.style.paddingRight = lockPaddingValue;\r\n    }\r\n  }\r\n  body.style.paddingRight = lockPaddingValue;\r\n  body.classList.add('lock');\r\n  unLock = false;\r\n  setTimeout(function () {\r\n    unLock = true;\r\n  }, timeout);\r\n}\r\n\r\nfunction bodyUnLock() {\r\n  setTimeout(function () {\r\n    if (lockPadding.length > 0) {\r\n      for (let i = 0; i < lockPadding.length; i++) {\r\n        const el = lockPadding[i];\r\n        el.style.paddingRight = '0px';\r\n      }\r\n    }\r\n    body.style.paddingRight = '0px';\r\n    body.classList.remove('lock');\r\n  }, timeout);\r\n  unLock = false;\r\n  setTimeout(function () {\r\n    unLock = true;\r\n  }, timeout);\r\n}\r\n\r\ndocument.addEventListener('keydown', function (e) {\r\n  if (e.which === 27 && document.querySelector('.popup.open')) {\r\n    const popupActive = document.querySelector('.popup.open');\r\n    popupClose(popupActive);\r\n  }\r\n});\r\n\n\n//# sourceURL=webpack://gulp-assembly/../src/assets/js/modules/popup.js?");

/***/ }),

/***/ "../src/assets/js/modules/spoiler.js":
/*!*******************************************!*\
  !*** ../src/assets/js/modules/spoiler.js ***!
  \*******************************************/
/***/ (() => {

eval("/*\r\n *\r\n * \tSimple spoiler\r\n *\tThe styles in the file spoiler.less\r\n *\r\n */\r\n\r\nfunction spoiler() {\r\n  const spoilers = document.querySelectorAll('.spoilers__title');\r\n\r\n  spoilers.forEach(spoiler => {\r\n    spoiler.addEventListener('click', e => {\r\n      const spoilerBody = e.target\r\n        .closest('.spoilers__item')\r\n        .querySelector('.spoilers__body');\r\n\r\n      spoilerBody.classList.toggle('spoilers__body_open');\r\n      e.target.classList.toggle('spoilers__title_open');\r\n\r\n      if (typeof gsap !== 'undefined') {\r\n        if (spoilerBody.classList.contains('open')) {\r\n          if (spoilerBody) {\r\n            gsap.to(spoilerBody, {\r\n              duration: 0.5,\r\n              ease: 'power1.in',\r\n              height: 'auto',\r\n              overflow: 'visible',\r\n              pointerEvents: 'auto',\r\n              opacity: 1,\r\n            });\r\n          }\r\n        } else {\r\n          gsap.to(spoilerBody, {\r\n            duration: 0.5,\r\n            ease: 'power1.in',\r\n            height: '0px',\r\n            overflow: 'hidden',\r\n            pointerEvents: 'none',\r\n            opacity: 0,\r\n          });\r\n        }\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\nspoiler();\r\n\n\n//# sourceURL=webpack://gulp-assembly/../src/assets/js/modules/spoiler.js?");

/***/ }),

/***/ "../src/assets/js/modules/tabs.js":
/*!****************************************!*\
  !*** ../src/assets/js/modules/tabs.js ***!
  \****************************************/
/***/ (() => {

eval("const tabs = document.querySelectorAll('.tabs__title');\r\n\r\nif (tabs) {\r\n  tabs.forEach(tab => {\r\n    tab.addEventListener('click', e => {\r\n      const tabName = e.target.dataset.tab;\r\n      const tabsContainer = e.target.closest('.tabs');\r\n\r\n      const tabsTitles = tabsContainer.querySelectorAll('.tabs__title');\r\n      tabsTitles.forEach(tabTitle => {\r\n        if (tabTitle === e.target) {\r\n          tabTitle.classList.add('tabs__title-active');\r\n        } else if (tabTitle.classList.contains('tabs__title-active')) {\r\n          tabTitle.classList.remove('tabs__title-active');\r\n        }\r\n      });\r\n\r\n      const tabsItem = tabsContainer.querySelectorAll('.tabs__body');\r\n      tabsItem.forEach(tabItem => {\r\n        if (tabItem.getAttribute('data-tab-name') === tabName) {\r\n          tabItem.classList.add('tabs__body-active');\r\n        } else if (tabItem.classList.contains('tabs__body-active')) {\r\n          tabItem.classList.remove('tabs__body-active');\r\n        }\r\n      });\r\n    });\r\n  });\r\n}\r\n\n\n//# sourceURL=webpack://gulp-assembly/../src/assets/js/modules/tabs.js?");

/***/ }),

/***/ "../src/assets/js/app.js":
/*!*******************************!*\
  !*** ../src/assets/js/app.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/functions.js */ \"../src/assets/js/modules/functions.js\");\n/* harmony import */ var _modules_dynamic_adapt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/dynamic_adapt.js */ \"../src/assets/js/modules/dynamic_adapt.js\");\n/* harmony import */ var _modules_popup_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/popup.js */ \"../src/assets/js/modules/popup.js\");\n/* harmony import */ var _modules_spoiler_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/spoiler.js */ \"../src/assets/js/modules/spoiler.js\");\n/* harmony import */ var _modules_tabs_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules/tabs.js */ \"../src/assets/js/modules/tabs.js\");\n/* harmony import */ var _modules_arrowsInputNumberStyle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modules/arrowsInputNumberStyle.js */ \"../src/assets/js/modules/arrowsInputNumberStyle.js\");\n/* harmony import */ var _modules_HorizontalMenu_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/HorizontalMenu.js */ \"../src/assets/js/modules/HorizontalMenu.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// import './modules/sliders.js';\r\n\r\n\r\n// let tl = gsap.timeline();\r\n\r\n\r\n// tl.to('.test-box__green', { duration: 2, x: 800, ease: 'elastic' });\r\n// tl.to('.test-box__green', { duration: 2, y: 200, ease: 'elastic' });\r\n// tl.to('.test-box__green', { duration: 2, x: 0, ease: 'elastic' });\r\n// tl.to('.test-box__green', { duration: 2, y: 0, ease: 'elastic' });\n\n//# sourceURL=webpack://gulp-assembly/../src/assets/js/app.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("../src/assets/js/app.js");
/******/ 	
/******/ })()
;